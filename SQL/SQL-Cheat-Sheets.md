


> Written with [StackEdit](https://stackedit.io/).

| ﻿SQL 	| The following notes are a summary of the Book:"Getting Started with SQL" 	|
|---	|-----	|
| SQL core funtions 	|  	|
| SELECT statement 	|  	|
| PRODUCT table: PRODUCT_ID, DESCRIPTION, PRICE 	|  	|
| CUSTOMER table: CUSTOMER_ID, NAME, REGION, STREET_ADDRESS, CITY, STATE, ZIP 
| SELECT *FROM customer; 	| Pull all the columns from the CUSTOMER table 	|
| SELECT customer_id, nameFROM customer; 	| Pick CUSTOMER_ID and NAME from the CUSTOMER table 	|
| SELECT product_id, description, price,price * 1.07 AS taxed_priceFROM product; 	| Generate a claculated column called TAXED_PRICE that is 7% higher thatn PRICE. We used an alias to gieve name to this expression. 	|
| SELECT product_id, description, price AS untaxed_price,price * 1.07 AS taxed_priceFROM product; 	| We can also uses aliases to apply a new name to an existing column within the query. 	|
| SELECT product_id, description, price, round(price * 1.07, 2) AS taxed_priceFROM product; 	| Using the round() function to round the TAXED_PRICE to two decimals. 	|
| SELECT name, city || ',' || state AS locationFROM customer; 	| Concatenate the CITY and STATE fields from the CUSTOMER table as well as put a comma and space between them to create a lOCATION value 	|
| SELECT NAME,STREET_ADDRESS || ' ' || CITY || ', ' || STATE || ' ' || ZIPAS SHIP_ADDRESSFROM CUSTOMER; 	| You can even concatenate several fields inot a single SHIP_ADDRESS value. Concatenation should work with any data type (numbers, dates, etc.) and treat it as text when merging. The ZIP field shown here is a number, but it was implicitly converted to text during concatenation. Many database platforms use double pipes (||) to concatenate, but MySQL and some others require using a CONCAT() function. 	|
| WHERE clause 	|  	|
| Using WHERE on Numbers 	|  	|
| SELECT *FROM station_dataWHERE year = 2010; 	| Get back records where the YEAR field equals 2010 	|
| SELECT *FROM station_dataWHERE year != 2010; 	| Get everything but 2010 	|
| SELECT *FROM station_dataWHERE year <> 2010; 	| The same as above 	|
| SELECT *FROM station_dataWHERE year BETWEEN 2005 AND 2010; 	| Now 2005 and 2010 are included in the range. 	|
| AND, OR, and IN Statements 	|  	|
| SELECT * FROM station_dataWHERE year >= 2005 AND year <= 2010; 	| A BETWEEN can alternatively be expressed using greater than or equal to and less than or equal to expressions and an AND statement. It is a little more verbose, but it demonstrates we can use two conditions with an AND. In this case, the year must be greater than or equal to 2005 and less than or equal to 2010 	|
| SELECT * FROM station_dataWHERE year > 2005 AND year < 2010; 	| If we wanted everything between 2005 and 2010 exclusively—i.e., not including thosetwo years—we would just get rid of the = characters. Only 2006, 2007, 2008, and 2009would then qualify 	|
| SELECT * FROM station_dataWHERE MONTH = 3 OR MONTH = 6 OR MONTH = 9 OR MONTH = 12; 	| We also have the option of using OR. In an OR statement, at least one of the criteria must be true for the record to qualify. If we wanted only records with months 3, 6, 9, or 12, we could use an OR to accomplish that 	|
| SELECT * FROM station_dataWHERE MONTH IN (3,6,9,12); 	| This is a little verbose. A more efficient way to accomplish this is using an IN statement to provide valid list of values 	|
| SELECT * FROM station_dataWHERE MONTH NOT IN (3,6,9,12); 	| If we wanted everything except 3, 6, 9, and 12, we could use NOT IN 	|
| SELECT * FROM station_dataWHERE MONTH % 3 = 0; 	| You can use other math expressions in your WHERE statements too. Earlier, we weretrying to filter on months 3, 6, 9, and 12. If you wanted only months divisible by 3(the “quarter” months), you could use the modulus operator (%). The modulus is similarto the division operator (/), but it returns the remainder instead of the quotient. Aremainder of 0 means there is no remainder at all, so you can leverage this logic bylooking for a remainder of 0 with modulus 3.In English, this means “give me all months where dividing by 3 gives me a remainderof 0. Oracle does not support the modulus operator. It instead uses theMOD() function. 	|
| Using WHERE on Text 	|  	|
| SELECT * FROM station_data WHERE report_code = '513A63' 	| You can use =, AND, OR, and IN statements with text. However, when using text, you must wrap literals (or text values you specify) in single quotes. Notice that because the report_code field is text (not a number), we need to put single quotes around '513A63' to qualify it. 	|
| SELECT * FROM station_dataWHERE report_code IN ('513A63','1F8A7B','EF616A') 	| This single-quote rule applies to all text operations, including this IN operation 	|
| SELECT * FROM station_dataWHERE length(report_code) != 6 	| the length() function will count the number ofcharacters for a given value. So, if we were assigned quality control and needed toensure every report_code was six characters in length, we would want to make sureno records come back when running this query 	|
| SELECT * FROM station_dataWHERE report_code LIKE 'A%' 	| Another common operation is to use wildcards with a LIKE expression, where % is any number of characters and _ is any single character. Any other character is interpretedliterally. So, if you wanted to find all report codes that start with the letter “A,”you would run this statement to find “A” followed by any characters 	|
| SELECT * FROM station_dataWHERE report_code LIKE 'B_C%' 	| If you wanted to find all report codes that have a “B” as the first character and a “C” as the third character, you would specify an underscore (_) for the second position, and follow with any number of characters after the “C” 	|
| Do not be confused by the % being used for two different purposes. Earlier we used it to perform a modulus operation, but in a LIKE statement it is a wildcard in a text pattern. Like some other symbols and characters in SQL, the context in which it is used defines its functionality 	|  	|
| Using WHERE on Booleans 	|  	|
| SELECT * FROM station_dataWHERE tornado = true AND hail = true; 	| Booleans are true/false values. In the database world, typically false is expressed as 0 and true is expressed as 1. Some database platforms (like MySQL) allow you toimplicitly use the words true and false to qualify, as shown here 	|
| SELECT * FROM station_dataWHERE tornado = 1 AND hail = 1; 	| SQLite, however, does not support this. It expects you to explicitly use 1 for true and 0 for false. If you wanted all records where there was tornado and hail, you would run this statement: 	|
| SELECT * FROM station_dataWHERE tornado AND hail; 	| If you are looking for just true values, you do not even have to use the = 1 expression. Because the fields are already Boolean (behind the scenes, every WHERE condition boils down to a Boolean expression), they inherently qualify by themselves. Hence, you can achieve the same results by running the following query 	|
| SELECT *FROM station_data WHERE tornado = 0 AND hail = 1; 	| However, qualifying for false conditions needs to be explicit. To get all records with no tornado but with hail, run this query 	|
| SELECT *FROM station_data WHERE NOT tornado AND hail; 	| You can also use the NOT keyword to qualify tornado as false 	|
| Handling NULL 	|  	|
| You may have noticed that some columns, such as station_pressure and snow_depth, have null values (Figure 5-3). A null is a value that has no value. It is the complete absence of any content. It is a vacuous state. In layman’s terms, it is blank. 	|  	|
| SELECT * FROM station_data WHERE snow_depth IS NULL; 	| Null values cannot be determined with an =. You need to use the IS NULL or IS NOTNULL statements to identify null values. So, to get all records with no recordedsnow_depth, you could run this query 	|
| Do not confuse nulls with empty text, which is two single quotes with nothing in them (i.e., ''). This also applies to whitespace text (i.e., ' '). These will be treated as values and never will be considered null. A null is definitely not the same as 0 either, because 0 is a value, whereas null is an absence of a value. 	|  	|
| SELECT * FROM station_data WHERE precipitation <= 0.5; 	| Nulls can be very annoying to handle when composing WHERE statements. If you wanted to query all records where precipitation is less than 0.5, you could writethis statement 	|
| SELECT * FROM station_data WHERE precipitation IS NULL OR precipitation <= 0.5; 	| But have you considered the null values? What if for this query you wanted nulls to be included? Because null is not 0 or any number, it will not qualify. Nulls rarely qualifywith anything and almost always get filtered out in a WHERE unless you explicitlyhandle them. So you have to use an OR to include nulls 	|
| SELECT * FROM station_data WHERE coalesce(precipitation, 0) <= 0.5; 	| A more elegant way of handling null values is to use the coalesce() function, whichwill turn a possibly null value into a specified default value if it is null. Otherwise, itwill leave the value as is. The first argument is the possibly null value, and the secondis the value to use if it is null. So if we wanted all nulls to be treated as 0 within ourcondition, we could coalesce() the precipitation field to convert null to 0 	|
| SELECT report_code, coalesce(precipitation, 0) AS rainfall FROM station_data; 	| Like any function, a coalesce() can be used in the SELECT statement too, and not justthe WHERE. This is helpful if you want to pretty up a report and not have null valuesdisplayed, but rather have some placeholder—for example, 0, “N/A” or “None”—which is more meaningful to most people 	|
| Grouping Conditions 	|  	|
| When you start chaining AND and OR together, it is good to group them deliberately. You need to make sure that you organize each set of conditions between each OR in a way that groups related conditions 	|  	|
| SELECT * FROM station_data WHERE rain = 1 AND temperature <= 32 OR snow_depth > 0; 	| Say you were looking for sleet or snow conditions. For sleet to happen, there must be rain and a temperature less than or equal to 32 degrees Fahrenheit. You can test for that sleet condition or a snow depth greaterthan 0, as shown here 	|
| SELECT * FROM station_data WHERE (rain = 1 AND temperature <= 32) OR snow_depth > 0 	| But there is one possible problem here. While this technically works, there is a degreeof ambiguity that we were lucky SQLite interpreted correctly. The reason is due to theunclear question of “What conditions belong to the AND and what conditions belongto the OR?” The SQL interpreter could derail quickly and incorrectly interpret that weare looking for rain AND another condition where either the temperature is below 32OR the snow depth is greater than 0. The semantics are not clear, and in more complicatedSQL this could confuse not only people but also the machine. This is why it is better to explicitly group conditions in parentheses 	|
| Group BY and ORDER BY 	|  	|
| Grouping Records 	|  	|
| SELECT COUNT(*) AS record_count FROM station_data; 	| First, perform the simplest aggregation: count the number of records in a table. The COUNT(*) means to count the records 	|
| SELECT COUNT(*) AS record_count FROM station_data WHERE tornado = 1; 	| The COUNT(*) means to count the records. We can also use this in combination withother SQL operations, like WHERE. To count the number of records where a tornadowas present, input the following 	|
| SELECT year, COUNT(*) AS record_count FROM station_data WHERE tornado = 1GROUP BY year; 	| We identified 3,000 records with tornadoes present. But what if we wanted to separatethe count by year? We can do that too with this query 	|
| SELECT year, month, COUNT(*) AS record_count FROM station_dataWHERE tornado = 1GROUP BY year, month; 	| We can slice this data on more than one field. If we wanted a count by year and month, we could group on the month field as well 	|
| SELECT year, month, COUNT(*) AS record_count FROM station_dataWHERE tornado = 1GROUP BY 1, 2; 	| Alternatively, we can use ordinal positions instead of specifying the columns in theGROUP BY. The ordinal positions correspond to each item’s numeric position in theSELECT statement 	|
| Note that not all platforms support ordinal positions. With Oracle and SQL Server, for example, you will have to rewrite the entire column name or expression in the GROUP BY. 	|  	|
| Ordering Records 	|  	|
| SELECT year, month, COUNT(*) AS record_count FROM station_dataWHERE tornado = 1GROUP BY year, monthORDER BY year, month; 	| Notice that the month column is not in a natural sort we would expect. This is a goodtime to bring up the ORDER BY operator, which you can put at the end of a SQL statement (after any WHERE and GROUP BY). If you wanted to sort by year, and then month, you could just add this command 	|
| SELECT year, month, COUNT(*) AS record_count FROM station_dataWHERE tornado = 1GROUP BY year, monthORDER BY year DESC, month 	| However, you are probably more interested in recent data and would like it at the top.By default, sorting is done with the ASC operator, which orders the data in ascendingorder. If you want to sort in descending order instead, apply the DESC operator to theordering of year to make more recent records appear at the top of the results 	|
| Aggregate Functions 	|  	|
| We already used the COUNT(*) function to count records. But there are other aggregation functions, including SUM(), MIN(), MAX(), and AVG(). We can use aggregation functions on a specific column to perform some sort of calculation on it. 	|  	|
| SELECT COUNT(snow_depth) as recorded_snow_depth_countFROM station_data; 	| But first let’s look at another way to use COUNT(). The COUNT() function can be usedfor a purpose other than simply counting records. If you specify a column instead ofan asterisk, it will count the number of non-null values in that column. For instance,we can take a count of snow_depth recordings, which will count the number of nonnullvalues 	|
| Aggregate functions such as COUNT(), SUM(), AVG(), MIN(), and MAX() will never include null values in their calculations. Only non- null values will be considered. 	|  	|
| SELECT month, AVG(temp) as avg_tempFROM station_dataWHERE year >= 2000GROUP BY month; 	| Let’s move on to other aggregation tasks. If you wanted to find the average temperature for each month since 2000, you could filter for years 2000 and later, group by month, and perform an average on temp 	|
| SELECT month, round(AVG(temp),2) as avg_tempFROM station_dataWHERE year >= 2000GROUP BY month; 	| As always, you can use functions on the aggregated values and perform tasks such asrounding to make them look nicer 	|
| SELECT year, SUM(snow_depth) as total_snowFROM station_dataWHERE year >= 2000GROUP BY year; 	| SUM() is another common aggregate operation. To find the sum of snow depth byyear since 2000, run this query. Alos group by year. 	|
| SELECT year,SUM(snow_depth) as total_snow,SUM(precipitation) as total_precipitation,MAX(precipitation) as max_precipitationFROM station_dataWHERE year >= 2000GROUP BY year; 	| There is no limitation on how many aggregate operations you can use in a singlequery. Here we find the total_snow and total_precipitation for each year since2000 in a single query, as well as the max_precipitation 	|
| SELECT year,SUM(precipitation) as tornado_precipitationFROM station_dataWHERE tornado = 1GROUP BY year; 	| It may not be apparent yet, but you can achieve some very specific aggregations byleveraging the WHERE. If you wanted the total precipitation by year only when a tornado was present, you would just have to filter on tornado being true. This will only include tornado-related precipitation in the totals 	|
| The HAVING Statement 	|  	|
| Suppose you wanted to filter out records based on an aggregated value. While your first instinct might be to use a WHERE statement, this actually will not work because the WHERE filters records, and does not filter aggregations 	|  	|
| SELECT year,SUM(precipitation) as total_precipitationFROM station_dataWHERE total_precipitation > 30GROUP BY year; 	| For example, if you try to use a WHERE to filter results where total_precipitation is greater than 30, this will error out 	|
| Why does this not work? You cannot filter on aggregated fields using WHERE. You have to use the HAVING keyword to accomplish this. The way aggregation works is that the software processes record by record, finding which ones it wants to keep based on the WHERE condition. After that, it crunches the records down on the GROUP BY and performs any aggregate functions, such as SUM(). 	|  	|
| SELECT year,SUM(precipitation) as total_precipitationFROM station_dataGROUP BY yearHAVING total_precipitation > 30; 	| If we wanted to filter on the SUM() value, we would need the filter to take place after it is calculated. This is where HAVING can be applied 	|
| HAVING is the aggregated equivalent to WHERE. The WHERE keyword filters individual records, but HAVING filters aggregations. 	|  	|
| SELECT year,SUM(precipitation) as total_precipitationFROM station_dataGROUP BY yearHAVING SUM(precipitation) > 30 	| Note that some platforms, including Oracle, do not support aliases in the HAVING statement (just like the GROUP BY). This means you must specify the aggregate function again in the HAVING statement. If you were running the preceding query on an Oracle database, you would have to write it like this 	|
| Getting Distincct Records 	|  	|
| SELECT station_number FROM station_data; 	| It is not uncommon to want a set of distinct results from a query. We know there are 28,000 records in our station_data table. But suppose we want to get a distinct listof the station_number values? If we run this query, we will get duplicates 	|
| SELECT DISTINCT station_number FROM station_data; 	| If we want a distinct list of station numbers without any duplicates, we can use the DISTINCT keyword 	|
| SELECT DISTINCT station_number, year FROM station_data; 	| You can also get distinct results for more than one column. If you need the distinctstation_number and year sets, just include both of those columns in the SELECTstatement 	|
| CASE Statemensts 	|  	|
| The CASE statement 	|  	|
| A CASE statement allows us to map one or more conditions to a corresponding value for each condition. You start a CASE statement with the word CASE and conclude it with an END. Between those keywords, you specify each condition with a WHEN [condition] THEN [value], where the [condition] and the corresponding [value] are supplied by you. After specifying the condition–value pairs, you can have a catch-all value to default to if none of the conditions were met, which is specified in the ELSE. 	|  	|
| SELECT report_code, year, month, day, wind_speed,CASEWHEN wind_speed >= 40 THEN 'HIGH'WHEN wind_speed >= 30 AND wind_speed < 40 THEN 'MODERATE'ELSE 'LOW'END as wind_severityFROM station_data; 	| For example, we could categorize wind_speed into wind_severity categories, where any speed greater than 40 is 'HIGH', 30 to 40 is 'MODERATE', and anything less is 'LOW' 	|
| SELECT report_code, year, month, day, wind_speed,CASEWHEN wind_speed >= 40 THEN 'HIGH'WHEN wind_speed >= 30 THEN 'MODERATE'ELSE 'LOW'END as wind_severityFROM station_data; 	| We can actually omit the AND wind_speed < 40 condition. Here is why: the machine reads a CASE statement from top to bottom, and the first condition it finds true is theone it uses (and it will stop evaluating subsequent conditions). So if we have a recordwith a wind_speed of 43, we can be certain it will be evaluated as 'HIGH'. Although itis greater than 30, it will not be assigned 'MODERATE' because it will not get to thatpoint. Knowing this allows us to create a slightly more efficient query 	|
| Gouping CASE Statements 	|  	|
| SELECT year,CASE WHEN wind_speed >= 40 THEN 'HIGH'WHEN wind_speed >= 30 THEN 'MODERATE'ELSE 'LOW' END as wind_severity,COUNT(*) as record_countFROM station_dataGROUP BY 1, 2; 	| When you create CASE statements and group them, you can create some very powerful transformations. Converting values based on one or more conditions before aggregating them gives us even more possibilities to slice data in interesting ways. Elaborating on our previous example, we can group on year and wind_severity and get a count of records for each one as shown here (also notice we use GROUP BY with ordinal positions so we do not have to rewrite the wind_severity case expression in the GROUP BY) 	|
| The "Zero/Null" CASE Trick 	|  	|
| You can do some clever tricks with the CASE statement. One simple but helpful pattern is the “zero/null” CASE trick. This allows you to apply different “filters” for different aggregate values, all in a single SELECT query. You could never accomplish this in a WHERE because the WHERE applies a filter to everything. But you can use a CASE to create a different filter condition for each aggregate value. 	|  	|
| #Tornado precipitationSELECT year, month, SUM(precipitation) as tornado_precipitationFROM station_data WHERE tornado = 1 GROUP BY year, month;#Non-tornado precipitation SELECT year, month, SUM(precipitation) as non_tornado_precipitationFROM station_dataWHERE tornado = 0 GROUP BY year, month; 	| Say you wanted to aggregate precipitation into two sums, tornado_precipitation and non_tornado_precipitation, and GROUP BY year and month. The logic is primarily dependent on two fields: precipitation and tornado. But how exactly do youcode this? If you give it some thought, you will realize you cannot do this with a WHERE statement unless you do two separate queries (one for tornado being true and the other false) 	|
| SELECT year, month,SUM(CASE WHEN tornado = 1 THEN precipitation ELSE 0 END) as tornado_precipitation,SUM(CASE WHEN tornado = 0 THEN precipitation ELSE 0 END) as non_tornado_precipitationFROM station_dataGROUP BY year, month; 	| But it is possible to do this in a single query using a CASE statement. You can move the tornado conditions from the WHERE to a CASE, and make the value 0 if the condition is false. Then you can SUM those CASE statements 	|
| SELECT year,MAX(CASE WHEN tornado = 0 THEN precipitation ELSE NULL END) as max_non_tornado_precipitation,MAX(CASE WHEN tornado = 1 THEN precipitation ELSE NULL END) as max_tornado_precipitationFROM station_dataGROUP BY year; 	| aggregation tasks. By leveraging a condition to make a value 0 if the condition is notmet, we effectively ignore that value and exclude it from the SUM (because adding 0has no impact).You could also do this with MIN or MAX operations, and use a null instead of 0 to makesure values with certain conditions are never considered. You can find the maximumprecipitation when tornadoes were present and when they were not (Figure 7-3) asfollows 	|
| SELECT month, AVG(CASE WHEN rain OR hail THEN temperature ELSE null END) AS avg_precipitation_temp,AVG(CASE WHEN NOT (rain OR hail) THEN temperature ELSE null END) AS avg_non_precipitation_tempFROM STATION_DATAWHERE year > 2000 GROUP BY month; 	| Just like with the WHERE statement, you can use any Boolean expressions in a CASE statement, including functions and AND, OR, and NOT statements. The following query will find the average temperatures by month when rain/hail was present versus not present after the year 2000 	|
| JOIN 	|  	|
| INNER JOIN 	|  	|
| CUSTOMER table: CUSTOMER_ID, NAME, REGION, STREET_ADDRESS, CITY, STATE, ZIP 	|  	|
| CUSTOMER_ORDER table: ORDER_ID, ORDER_DATE, SHIP_DATE, CUSTOMER_ID, PRODUCT_ID, ORDER_ID, SHIPPED 	|  	|
| SELECT ORDER_ID,CUSTOMER.CUSTOMER_ID,ORDER_DATE,SHIP_DATE,NAME,STREET_ADDRESS,CITY,STATE,ZIP,PRODUCT_ID,ORDER_QTYFROM CUSTOMER INNER JOIN CUSTOMER_ORDERON CUSTOMER.CUSTOMER_ID = CUSTOMER_ORDER.CUSTOMER_ID; 	| The first thing you may notice is we were able to query fields from both CUSTOMERand CUSTOMER_ORDER. It is almost like we took those two tables and temporarilymerged them into a single table, which we queried off of. In effect, that is exactly whatwe did!Let’s break down how this was accomplished. First, we select the fields we want fromthe CUSTOMER and CUSTOMER_ORDER tablesIn this case, we want to show customer address information for each order. Alsonotice that because CUSTOMER_ID is in both tables, we had to explicitly choose one(although it should not matter which). In this case, we chose the CUSTOMER_ID inCUSTOMER using an explicit syntax, CUSTOMER.CUSTOMER_IDFinally, the important part that temporarily merges two tables into one. The FROMstatement is where we execute our INNER JOIN. We specify that we are pulling fromCUSTOMER and inner joining it with CUSTOMER_ORDER, and that the commonality is on the CUSTOMER_ID fields (which have to be equal to line up)There are noorders for Rex Tooling Inc and Prairie Construction, and because of this the INNERJOIN excluded them from the query. It will only show records that inclusively exist inboth tables. With an INNER JOIN, any records that do not have a common joined value in both tables will be excluded. If we want to include all records from the CUSTOMER table, we can accomplish this with a LEFT JOIN. 	|
| LEFT JOIN 	|  	|
| CUSTOMER table: CUSTOMER_ID, NAME, REGION, STREET_ADDRESS, CITY, STATE, ZIP 	|  	|
| CUSTOMER_ORDER table: ORDER_ID, ORDER_DATE, SHIP_DATE, CUSTOMER_ID, PRODUCT_ID, ORDER_ID, SHIPPED 	|  	|
| SELECT ORDER_ID,CUSTOMER.CUSTOMER_ID,ORDER_DATE,SHIP_DATE,NAME,STREET_ADDRESS,CITY,STATE,ZIP,PRODUCT_ID,ORDER_QTYFROM CUSTOMER LEFT JOIN CUSTOMER_ORDERON CUSTOMER.CUSTOMER_ID = CUSTOMER_ORDER.CUSTOMER_ID; 	| Those two customers, Rex Tooling Inc and Prairie Construction, were excluded fromthe INNER JOIN on CUSTOMER_ID because they had no orders to join on. But supposewe did want to include them anyway. Often, we may want to join tables and see, forexample, all customers, even if they had no orders. For those two customers, notice all the fields that come from CUS TOMER_ORDER are null, because there were no orders to join to. Instead of omitting them like the INNER JOIN did, the LEFT JOIN just made them null. 	|
| SELECTCUSTOMER.CUSTOMER_ID,NAME AS CUSTOMER_NAMEFROM CUSTOMER LEFT JOIN CUSTOMER_ORDERON CUSTOMER.CUSTOMER_ID = CUSTOMER_ORDER.CUSTOMER_IDWHERE ORDER_ID IS NULL; 	| It is also common to use LEFT JOIN to check for “orphaned” child records that have no parent, or conversely a parent that has no children (e.g., orders that have no customers, or customers that have no orders). You can use a WHERE statement to check for null values that are a result of the LEFT JOIN. Modifying our previous example, we can filter for customers that have no orders by filtering any field from the right table that is null 	|
| Other JOIN Types 	|  	|
| There is a RIGHT JOIN operator, which performs a right outer join that is almost identical to the left outer join. It flips the direction of the join and includes all records from the right table. However, the RIGHT JOIN is rarely used and should be avoided. You should stick to convention and prefer left outer joins with LEFT JOIN, and put the “all records” table on the left side of the join operator 	|  	|
| There also is a full outer join operator called OUTER JOIN that includes all records from both tables. It does a LEFT JOIN and a RIGHT JOIN simultaneously, and can have null records in both tables. It can be helpful to find orphaned records in both directions simultaneously in a single query, but it also is seldom used. 	|  	|
| RIGHT JOIN and OUTER JOIN are not supported in SQLite due to their highly niche nature. But most database solutions feature them. 	|  	|
	
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwODk3MDg5ODNdfQ==
-->